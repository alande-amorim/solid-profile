{"id":"node_modules/@inrupt/solid-client-authn-core/dist/storage/StorageUtility.js","dependencies":[{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/dist/storage/StorageUtility.js.map","includedInParent":true,"mtime":1611945169047},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/src/storage/StorageUtility.ts","includedInParent":true,"mtime":1611945169047},{"name":"/Users/amorim.alande/Projects/pod-profile/package.json","includedInParent":true,"mtime":1612372540913},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/package.json","includedInParent":true,"mtime":1611945169047},{"name":"../util/validateSchema","loc":{"line":7,"column":49},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/dist/storage/StorageUtility.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/dist/util/validateSchema.js"},{"name":"../errors/InruptError","loc":{"line":8,"column":46},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/dist/storage/StorageUtility.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-core/dist/errors/InruptError.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.saveSessionInfoToStorage = exports.loadOidcContextFromStorage = exports.getSessionIdFromOauthState = void 0;\nconst validateSchema_1 = __importDefault(require(\"../util/validateSchema\"));\nconst InruptError_1 = __importDefault(require(\"../errors/InruptError\"));\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\n    return storageUtility.getForUser(oauthState, \"sessionId\");\n}\nexports.getSessionIdFromOauthState = getSessionIdFromOauthState;\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\n    try {\n        const [issuerIri, codeVerifier, storedRedirectIri, dpop,] = await Promise.all([\n            storageUtility.getForUser(sessionId, \"issuer\", {\n                errorIfNull: true,\n            }),\n            storageUtility.getForUser(sessionId, \"codeVerifier\"),\n            storageUtility.getForUser(sessionId, \"redirectUri\"),\n            storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\n        ]);\n        const issuerConfig = await configFetcher.fetchConfig(issuerIri);\n        return {\n            codeVerifier,\n            redirectUri: storedRedirectIri,\n            issuerConfig,\n            dpop: dpop === \"true\",\n        };\n    }\n    catch (e) {\n        throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`);\n    }\n}\nexports.loadOidcContextFromStorage = loadOidcContextFromStorage;\nasync function saveSessionInfoToStorage(storageUtility, sessionId, idToken, webId, isLoggedIn, refreshToken, secure) {\n    if (refreshToken !== undefined) {\n        await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\n    }\n    if (idToken !== undefined) {\n        await storageUtility.setForUser(sessionId, { idToken }, { secure });\n    }\n    if (webId !== undefined) {\n        await storageUtility.setForUser(sessionId, { webId }, { secure });\n    }\n    if (isLoggedIn !== undefined) {\n        await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\n    }\n}\nexports.saveSessionInfoToStorage = saveSessionInfoToStorage;\nclass StorageUtility {\n    constructor(secureStorage, insecureStorage) {\n        this.secureStorage = secureStorage;\n        this.insecureStorage = insecureStorage;\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY = \"tmp-resource-server-session-info\";\n    }\n    getKey(userId) {\n        return `solidClientAuthenticationUser:${userId}`;\n    }\n    async getUserData(userId, secure) {\n        const stored = await (secure\n            ? this.secureStorage\n            : this.insecureStorage).get(this.getKey(userId));\n        if (stored === undefined) {\n            return {};\n        }\n        try {\n            return JSON.parse(stored);\n        }\n        catch (err) {\n            throw new InruptError_1.default(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\n        }\n    }\n    async setUserData(userId, data, secure) {\n        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\n    }\n    async get(key, options) {\n        const value = await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage\n            : this.insecureStorage).get(key);\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n            throw new InruptError_1.default(`[${key}] is not stored`);\n        }\n        return value;\n    }\n    async set(key, value, options) {\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\n    }\n    async delete(key, options) {\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\n    }\n    async getForUser(userId, key, options) {\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n        let value;\n        if (!userData || !userData[key]) {\n            value = undefined;\n        }\n        value = userData[key];\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n            throw new InruptError_1.default(`Field [${key}] for user [${userId}] is not stored`);\n        }\n        return value || undefined;\n    }\n    async setForUser(userId, values, options) {\n        let userData;\n        try {\n            userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n        }\n        catch (_a) {\n            userData = {};\n        }\n        await this.setUserData(userId, { ...userData, ...values }, options === null || options === void 0 ? void 0 : options.secure);\n    }\n    async deleteForUser(userId, key, options) {\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n        delete userData[key];\n        await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\n    }\n    async deleteAllUserData(userId, options) {\n        await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\n    }\n    async storeResourceServerSessionInfo(webId, resourceServerIri, expiration) {\n        var _a;\n        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : \"{}\");\n        if (sessions.webId !== webId) {\n            sessions.sessions = {};\n        }\n        sessions.webId = webId;\n        sessions.sessions[resourceServerIri] = {\n            expiration,\n        };\n        await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\n    }\n    async clearResourceServerSessionInfo(resourceServerIri) {\n        var _a;\n        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : \"{}\");\n        if (sessions.sessions !== undefined) {\n            delete sessions.sessions[resourceServerIri];\n            if (Object.keys(sessions.sessions).length === 0) {\n                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, \"{}\");\n            }\n            else {\n                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\n            }\n        }\n    }\n    async safeGet(key, options = {}) {\n        const locallyStored = options.userId\n            ? await this.getForUser(options.userId, key, { secure: options.secure })\n            : await this.get(key, { secure: options.secure });\n        if (locallyStored) {\n            try {\n                const parsedObject = JSON.parse(locallyStored);\n                if (options.schema) {\n                    const val = validateSchema_1.default(options.schema, parsedObject);\n                    return val;\n                }\n                return parsedObject;\n            }\n            catch (err) {\n                let invalidObject;\n                if (options.userId) {\n                    invalidObject = await this.getForUser(options.userId, key, {\n                        secure: options.secure,\n                    });\n                }\n                else {\n                    invalidObject = await this.get(key, {\n                        secure: options.secure,\n                    });\n                }\n                throw new InruptError_1.default(`Object ${JSON.stringify(invalidObject)} does not match expected schema: ${JSON.stringify(options.schema)}: ${err.toString()}. \\n Please clear your local storage.`);\n            }\n        }\n        return undefined;\n    }\n}\nexports.default = StorageUtility;\n"},"sourceMaps":{"js":{"version":3,"file":"StorageUtility.js","sourceRoot":"","sources":["../../src/storage/StorageUtility.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\n/**\n * A helper class that will validate items taken from local storage\n */\nimport validateSchema from \"../util/validateSchema\";\nimport IStorage from \"./IStorage\";\nimport IStorageUtility from \"./IStorageUtility\";\nimport InruptError from \"../errors/InruptError\";\nimport { IIssuerConfig } from \"../login/oidc/IIssuerConfig\";\nimport { IIssuerConfigFetcher } from \"../login/oidc/IIssuerConfigFetcher\";\n\nexport type OidcContext = {\n  issuerConfig: IIssuerConfig;\n  codeVerifier?: string;\n  redirectUri?: string;\n  dpop: boolean;\n};\n\nexport async function getSessionIdFromOauthState(\n  storageUtility: IStorageUtility,\n  oauthState: string\n): Promise<string | undefined> {\n  return storageUtility.getForUser(oauthState, \"sessionId\");\n}\n\n/**\n * Based on the provided state, this looks up contextual information stored\n * before redirecting the user to the OIDC issuer.\n * @param sessionId The state (~ correlation ID) of the OIDC request\n * @param storageUtility\n * @param configFetcher\n * @returns Information stored about the client issuing the request\n */\nexport async function loadOidcContextFromStorage(\n  sessionId: string,\n  storageUtility: IStorageUtility,\n  configFetcher: IIssuerConfigFetcher\n): Promise<OidcContext> {\n  try {\n    const [\n      issuerIri,\n      codeVerifier,\n      storedRedirectIri,\n      dpop,\n    ] = await Promise.all([\n      storageUtility.getForUser(sessionId, \"issuer\", {\n        errorIfNull: true,\n      }),\n      storageUtility.getForUser(sessionId, \"codeVerifier\"),\n      storageUtility.getForUser(sessionId, \"redirectUri\"),\n      storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\n    ]);\n\n    // Unlike openid-client, this looks up the configuration from storage\n    const issuerConfig = await configFetcher.fetchConfig(issuerIri as string);\n    return {\n      codeVerifier,\n      redirectUri: storedRedirectIri,\n      issuerConfig,\n      dpop: dpop === \"true\",\n    };\n  } catch (e) {\n    throw new Error(\n      `Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`\n    );\n  }\n}\n\nexport async function saveSessionInfoToStorage(\n  storageUtility: IStorageUtility,\n  sessionId: string,\n  idToken?: string,\n  webId?: string,\n  isLoggedIn?: string,\n  refreshToken?: string,\n  secure?: boolean\n): Promise<void> {\n  // TODO: Investigate why this does not work with a Promise.all\n  if (refreshToken !== undefined) {\n    await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\n  }\n  if (idToken !== undefined) {\n    await storageUtility.setForUser(sessionId, { idToken }, { secure });\n  }\n  if (webId !== undefined) {\n    await storageUtility.setForUser(sessionId, { webId }, { secure });\n  }\n  if (isLoggedIn !== undefined) {\n    await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\n  }\n}\n\nexport type ResourceServerSession = {\n  webId: string;\n  sessions: Record<\n    string,\n    {\n      expiration: number;\n    }\n  >;\n};\n\n// TOTEST: this does not handle all possible bad inputs for example what if it's not proper JSON\n/**\n * @hidden\n */\nexport default class StorageUtility implements IStorageUtility {\n  constructor(\n    private secureStorage: IStorage,\n    private insecureStorage: IStorage\n  ) {}\n\n  private getKey(userId: string): string {\n    return `solidClientAuthenticationUser:${userId}`;\n  }\n\n  private RESOURCE_SERVER_SESSION_INFORMATION_KEY =\n    \"tmp-resource-server-session-info\";\n\n  private async getUserData(\n    userId: string,\n    secure?: boolean\n  ): Promise<Record<string, string>> {\n    const stored = await (secure\n      ? this.secureStorage\n      : this.insecureStorage\n    ).get(this.getKey(userId));\n\n    if (stored === undefined) {\n      return {};\n    }\n\n    try {\n      return JSON.parse(stored);\n    } catch (err) {\n      throw new InruptError(\n        `Data for user [${userId}] in [${\n          secure ? \"secure\" : \"unsecure\"\n        }] storage is corrupted - expected valid JSON, but got: ${stored}`\n      );\n    }\n  }\n\n  private async setUserData(\n    userId: string,\n    data: Record<string, string>,\n    secure?: boolean\n  ): Promise<void> {\n    await (secure ? this.secureStorage : this.insecureStorage).set(\n      this.getKey(userId),\n      JSON.stringify(data)\n    );\n  }\n\n  async get(\n    key: string,\n    options?: { errorIfNull?: boolean; secure?: boolean }\n  ): Promise<string | undefined> {\n    const value = await (options?.secure\n      ? this.secureStorage\n      : this.insecureStorage\n    ).get(key);\n    if (value === undefined && options?.errorIfNull) {\n      throw new InruptError(`[${key}] is not stored`);\n    }\n    return value;\n  }\n\n  async set(\n    key: string,\n    value: string,\n    options?: { secure?: boolean }\n  ): Promise<void> {\n    return (options?.secure ? this.secureStorage : this.insecureStorage).set(\n      key,\n      value\n    );\n  }\n\n  async delete(key: string, options?: { secure?: boolean }): Promise<void> {\n    return (options?.secure ? this.secureStorage : this.insecureStorage).delete(\n      key\n    );\n  }\n\n  async getForUser(\n    userId: string,\n    key: string,\n    options?: { errorIfNull?: boolean; secure?: boolean }\n  ): Promise<string | undefined> {\n    const userData = await this.getUserData(userId, options?.secure);\n    let value;\n    if (!userData || !userData[key]) {\n      value = undefined;\n    }\n    value = userData[key];\n    if (value === undefined && options?.errorIfNull) {\n      throw new InruptError(\n        `Field [${key}] for user [${userId}] is not stored`\n      );\n    }\n    return value || undefined;\n  }\n\n  async setForUser(\n    userId: string,\n    values: Record<string, string>,\n    options?: { secure?: boolean }\n  ): Promise<void> {\n    let userData: Record<string, string>;\n    try {\n      userData = await this.getUserData(userId, options?.secure);\n    } catch {\n      // if reading the user data throws, the data is corrupted, and we want to write over it\n      userData = {};\n    }\n\n    await this.setUserData(userId, { ...userData, ...values }, options?.secure);\n  }\n\n  async deleteForUser(\n    userId: string,\n    key: string,\n    options?: { secure?: boolean }\n  ): Promise<void> {\n    const userData = await this.getUserData(userId, options?.secure);\n    delete userData[key];\n    await this.setUserData(userId, userData, options?.secure);\n  }\n\n  async deleteAllUserData(\n    userId: string,\n    options?: { secure?: boolean }\n  ): Promise<void> {\n    await (options?.secure ? this.secureStorage : this.insecureStorage).delete(\n      this.getKey(userId)\n    );\n  }\n\n  async storeResourceServerSessionInfo(\n    webId: string,\n    resourceServerIri: string,\n    expiration: number\n  ): Promise<void> {\n    const sessions: ResourceServerSession = JSON.parse(\n      (await this.insecureStorage.get(\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY\n      )) ?? \"{}\"\n    );\n    if (sessions.webId !== webId) {\n      // Clear all previously active sessions.\n      sessions.sessions = {};\n    }\n    sessions.webId = webId;\n    sessions.sessions[resourceServerIri] = {\n      expiration,\n    };\n    await this.insecureStorage.set(\n      this.RESOURCE_SERVER_SESSION_INFORMATION_KEY,\n      JSON.stringify(sessions)\n    );\n  }\n\n  async clearResourceServerSessionInfo(\n    resourceServerIri: string\n  ): Promise<void> {\n    const sessions: ResourceServerSession = JSON.parse(\n      (await this.insecureStorage.get(\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY\n      )) ?? \"{}\"\n    );\n    if (sessions.sessions !== undefined) {\n      delete sessions.sessions[resourceServerIri];\n\n      if (Object.keys(sessions.sessions).length === 0) {\n        // If there aren't any active sessions left, the whole object is cleared.\n        await this.insecureStorage.set(\n          this.RESOURCE_SERVER_SESSION_INFORMATION_KEY,\n          \"{}\"\n        );\n      } else {\n        await this.insecureStorage.set(\n          this.RESOURCE_SERVER_SESSION_INFORMATION_KEY,\n          JSON.stringify(sessions)\n        );\n      }\n    }\n  }\n\n  /**\n   * Get an object from storage with the guarantee that it matches a given schema.\n   *\n   * @param key The key to look up in storage.\n   * @param options Optional parameters:\n   *  - schema describing the expected JSON structure\n   *  - secure switch to specify the target storage\n   * @returns The storad object associated with the provided key iff it matches the\n   * provided schema.\n   */\n  async safeGet(\n    key: string,\n    options: {\n      schema?: Record<string, unknown>;\n      userId?: string;\n      secure?: boolean;\n    } = {}\n  ): Promise<unknown | undefined> {\n    // Check if key is stored locally\n    const locallyStored: string | undefined = options.userId\n      ? await this.getForUser(options.userId, key, { secure: options.secure })\n      : await this.get(key, { secure: options.secure });\n\n    // If it is stored locally, check the validity of the value\n    if (locallyStored) {\n      try {\n        const parsedObject = JSON.parse(locallyStored);\n        if (options.schema) {\n          const val = validateSchema(options.schema, parsedObject);\n          return val;\n        }\n        return parsedObject;\n      } catch (err) {\n        let invalidObject;\n        if (options.userId) {\n          invalidObject = await this.getForUser(options.userId, key, {\n            secure: options.secure,\n          });\n        } else {\n          invalidObject = await this.get(key, {\n            secure: options.secure,\n          });\n        }\n        throw new InruptError(\n          `Object ${JSON.stringify(\n            invalidObject\n          )} does not match expected schema: ${JSON.stringify(\n            options.schema\n          )}: ${err.toString()}. \\n Please clear your local storage.`\n        );\n      }\n    }\n    return undefined;\n  }\n}\n"]}},"error":null,"hash":"19232b9da1ce21ad91e8001057cc1c08","cacheData":{"env":{}}}