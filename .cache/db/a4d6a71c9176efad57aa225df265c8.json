{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js","dependencies":[{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js.map","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/src/login/oidc/redirectHandler/AuthCodeRedirectHandler.ts","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/package.json","includedInParent":true,"mtime":1612221001734},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1611945169054},{"name":"tsyringe","loc":{"line":16,"column":27},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/tsyringe/dist/esm5/index.js"},{"name":"@inrupt/oidc-client-ext","loc":{"line":17,"column":34},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/oidc-client-ext/dist/index.es.js"},{"name":"../../../authenticatedFetch/fetchFactory","loc":{"line":18,"column":31},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/authenticatedFetch/fetchFactory.js"}],"generated":{"js":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = exports.exchangeDpopToken = void 0;\nconst tsyringe_1 = require(\"tsyringe\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nconst fetchFactory_1 = require(\"../../../authenticatedFetch/fetchFactory\");\nasync function exchangeDpopToken(sessionId, issuer, issuerFetcher, clientRegistrar, code, codeVerifier, redirectUrl) {\n    const issuerConfig = await issuerFetcher.fetchConfig(issuer);\n    const client = await clientRegistrar.getClient({ sessionId }, issuerConfig);\n    return oidc_client_ext_1.getDpopToken(issuerConfig, client, {\n        grantType: \"authorization_code\",\n        code,\n        codeVerifier,\n        redirectUri: redirectUrl,\n    });\n}\nexports.exchangeDpopToken = exchangeDpopToken;\nexports.DEFAULT_LIFESPAN = 1800 * 1000;\nasync function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {\n    const webIdAsUrl = new URL(webId);\n    const resourceServerIri = webIdAsUrl.origin;\n    await authenticatedFetch(webId);\n    const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);\n    if (resourceServerResponse.status === 200) {\n        await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);\n        return;\n    }\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n}\nlet AuthCodeRedirectHandler = class AuthCodeRedirectHandler {\n    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar) {\n        this.storageUtility = storageUtility;\n        this.sessionInfoManager = sessionInfoManager;\n        this.issuerConfigFetcher = issuerConfigFetcher;\n        this.clientRegistrar = clientRegistrar;\n    }\n    async canHandle(redirectUrl) {\n        try {\n            const myUrl = new URL(redirectUrl);\n            return (myUrl.searchParams.get(\"code\") !== null &&\n                myUrl.searchParams.get(\"state\") !== null);\n        }\n        catch (e) {\n            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);\n        }\n    }\n    async handle(redirectUrl) {\n        if (!(await this.canHandle(redirectUrl))) {\n            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);\n        }\n        const url = new URL(redirectUrl);\n        const oauthState = url.searchParams.get(\"state\");\n        const storedSessionId = (await this.storageUtility.getForUser(oauthState, \"sessionId\", {\n            errorIfNull: true,\n        }));\n        const isDpop = (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\n            \"true\";\n        let tokens;\n        let authFetch;\n        if (isDpop) {\n            const issuer = (await this.storageUtility.getForUser(storedSessionId, \"issuer\", { errorIfNull: true }));\n            const codeVerifier = (await this.storageUtility.getForUser(storedSessionId, \"codeVerifier\", { errorIfNull: true }));\n            const storedRedirectIri = (await this.storageUtility.getForUser(storedSessionId, \"redirectUri\", { errorIfNull: true }));\n            tokens = await exchangeDpopToken(storedSessionId, issuer, this.issuerConfigFetcher, this.clientRegistrar, url.searchParams.get(\"code\"), codeVerifier, storedRedirectIri);\n            authFetch = await fetchFactory_1.buildDpopFetch(tokens.accessToken, tokens.refreshToken, tokens.dpopJwk);\n        }\n        else {\n            tokens = await oidc_client_ext_1.getBearerToken(url.toString());\n            authFetch = fetchFactory_1.buildBearerFetch(tokens.accessToken, tokens.refreshToken);\n        }\n        await this.storageUtility.setForUser(storedSessionId, {\n            idToken: tokens.idToken,\n            refreshToken: \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\n            webId: tokens.webId,\n            isLoggedIn: \"true\",\n        }, { secure: true });\n        await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);\n        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n        if (!sessionInfo) {\n            throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n        }\n        return Object.assign(sessionInfo, {\n            fetch: authFetch,\n        });\n    }\n};\nAuthCodeRedirectHandler = __decorate([\n    tsyringe_1.injectable(),\n    __param(0, tsyringe_1.inject(\"storageUtility\")),\n    __param(1, tsyringe_1.inject(\"sessionInfoManager\")),\n    __param(2, tsyringe_1.inject(\"issuerConfigFetcher\")),\n    __param(3, tsyringe_1.inject(\"clientRegistrar\")),\n    __metadata(\"design:paramtypes\", [Object, Object, Object, Object])\n], AuthCodeRedirectHandler);\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;\n"},"sourceMaps":{"js":{"version":3,"file":"AuthCodeRedirectHandler.js","sourceRoot":"","sources":["../../../../src/login/oidc/redirectHandler/AuthCodeRedirectHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport { inject, injectable } from \"tsyringe\";\nimport {\n  IClient,\n  IClientRegistrar,\n  IIssuerConfig,\n  IIssuerConfigFetcher,\n  IRedirectHandler,\n  ISessionInfo,\n  ISessionInfoManager,\n  IStorageUtility,\n} from \"@inrupt/solid-client-authn-core\";\nimport {\n  getDpopToken,\n  getBearerToken,\n  TokenEndpointResponse,\n  TokenEndpointDpopResponse,\n} from \"@inrupt/oidc-client-ext\";\nimport { JSONWebKey } from \"jose\";\nimport {\n  buildBearerFetch,\n  buildDpopFetch,\n} from \"../../../authenticatedFetch/fetchFactory\";\n\nexport async function exchangeDpopToken(\n  sessionId: string,\n  issuer: string,\n  issuerFetcher: IIssuerConfigFetcher,\n  clientRegistrar: IClientRegistrar,\n  code: string,\n  codeVerifier: string,\n  redirectUrl: string\n): Promise<TokenEndpointDpopResponse> {\n  const issuerConfig: IIssuerConfig = await issuerFetcher.fetchConfig(issuer);\n  const client: IClient = await clientRegistrar.getClient(\n    { sessionId },\n    issuerConfig\n  );\n  return getDpopToken(issuerConfig, client, {\n    grantType: \"authorization_code\",\n    code,\n    codeVerifier,\n    redirectUri: redirectUrl,\n  });\n}\n\n// A lifespan of 30 minutes is ESS's default. This could be removed if we configure the\n// server to return the remaining lifespan of the cookie.\nexport const DEFAULT_LIFESPAN = 1800 * 1000;\n\n/**\n * Stores the resource server session information in local storage, so that they\n * can be used on refresh.\n * @param webId\n * @param authenticatedFetch\n * @param storageUtility\n */\nasync function setupResourceServerSession(\n  webId: string,\n  authenticatedFetch: typeof fetch,\n  storageUtility: IStorageUtility\n): Promise<void> {\n  const webIdAsUrl = new URL(webId);\n  const resourceServerIri = webIdAsUrl.origin;\n  // Querying the /session endpoint does not set the cookie, but issuing an\n  // authenticated request to any actual resource (even public ones) does,\n  // so we fetch the user's WebID before checking the /session endpoint.\n  await authenticatedFetch(webId);\n  const resourceServerResponse = await authenticatedFetch(\n    `${resourceServerIri}/session`\n  );\n\n  if (resourceServerResponse.status === 200) {\n    await storageUtility.storeResourceServerSessionInfo(\n      webId,\n      resourceServerIri,\n      // Note that here, if the lifespan of the cookie was returned by the server,\n      // we'd expect a relative value (the remaining time of validity) rather than\n      // an absolute one (the moment when the cookie expires).\n      Date.now() + DEFAULT_LIFESPAN\n    );\n    return;\n  }\n  // In this case, the resource server either:\n  // - does not have the expected endpoint, or\n  // - does not recognize the user\n  // Either way, no cookie is expected to be set there, and any existing\n  // session information should be cleared.\n  await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n}\n\n/**\n * @hidden\n */\n@injectable()\nexport class AuthCodeRedirectHandler implements IRedirectHandler {\n  constructor(\n    @inject(\"storageUtility\") private storageUtility: IStorageUtility,\n    @inject(\"sessionInfoManager\")\n    private sessionInfoManager: ISessionInfoManager,\n    @inject(\"issuerConfigFetcher\")\n    private issuerConfigFetcher: IIssuerConfigFetcher,\n    @inject(\"clientRegistrar\") private clientRegistrar: IClientRegistrar\n  ) {}\n\n  async canHandle(redirectUrl: string): Promise<boolean> {\n    try {\n      const myUrl = new URL(redirectUrl);\n      return (\n        myUrl.searchParams.get(\"code\") !== null &&\n        myUrl.searchParams.get(\"state\") !== null\n      );\n    } catch (e) {\n      throw new Error(\n        `[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`\n      );\n    }\n  }\n\n  async handle(\n    redirectUrl: string\n  ): Promise<ISessionInfo & { fetch: typeof fetch }> {\n    if (!(await this.canHandle(redirectUrl))) {\n      throw new Error(\n        `AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`\n      );\n    }\n\n    const url = new URL(redirectUrl);\n    const oauthState = url.searchParams.get(\"state\") as string;\n\n    const storedSessionId = (await this.storageUtility.getForUser(\n      oauthState,\n      \"sessionId\",\n      {\n        errorIfNull: true,\n      }\n    )) as string;\n    const isDpop =\n      (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\n      \"true\";\n\n    let tokens: TokenEndpointResponse | TokenEndpointDpopResponse;\n    let authFetch: typeof fetch;\n\n    if (isDpop) {\n      // Since we throw if not found, the type assertion is okay\n      const issuer = (await this.storageUtility.getForUser(\n        storedSessionId,\n        \"issuer\",\n        { errorIfNull: true }\n      )) as string;\n      const codeVerifier = (await this.storageUtility.getForUser(\n        storedSessionId,\n        \"codeVerifier\",\n        { errorIfNull: true }\n      )) as string;\n      const storedRedirectIri = (await this.storageUtility.getForUser(\n        storedSessionId,\n        \"redirectUri\",\n        { errorIfNull: true }\n      )) as string;\n\n      tokens = await exchangeDpopToken(\n        storedSessionId,\n        issuer,\n        this.issuerConfigFetcher,\n        this.clientRegistrar,\n        // the canHandle function checks that the code is part of the query strings\n        url.searchParams.get(\"code\") as string,\n        codeVerifier,\n        storedRedirectIri\n      );\n      // The type assertion should not be necessary\n      authFetch = await buildDpopFetch(\n        tokens.accessToken,\n        tokens.refreshToken,\n        tokens.dpopJwk as JSONWebKey\n      );\n    } else {\n      tokens = await getBearerToken(url.toString());\n      authFetch = buildBearerFetch(tokens.accessToken, tokens.refreshToken);\n    }\n\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        idToken: tokens.idToken,\n        // TODO: We need a PR to oidc-client-js to add parsing of the\n        //  refresh_token from the redirect URL.\n        refreshToken:\n          \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\n        webId: tokens.webId,\n        isLoggedIn: \"true\",\n      },\n      { secure: true }\n    );\n\n    await setupResourceServerSession(\n      tokens.webId,\n      authFetch,\n      this.storageUtility\n    );\n\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n    if (!sessionInfo) {\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n    }\n\n    return Object.assign(sessionInfo, {\n      fetch: authFetch,\n    });\n  }\n}\n"]}},"error":null,"hash":"606436b0cdd0c3d1ae5f5388c15a556d","cacheData":{"env":{}}}