{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/authenticatedFetch/fetchFactory.js","dependencies":[{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/authenticatedFetch/fetchFactory.js.map","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/src/authenticatedFetch/fetchFactory.ts","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/package.json","includedInParent":true,"mtime":1612372540913},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1611945169054},{"name":"@inrupt/oidc-client-ext","loc":{"line":4,"column":34},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/authenticatedFetch/fetchFactory.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/oidc-client-ext/dist/index.es.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildDpopFetch = exports.buildBearerFetch = void 0;\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nfunction buildBearerFetch(authToken, _refreshToken) {\n    return (init, options) => {\n        return fetch(init, {\n            ...options,\n            credentials: \"include\",\n            headers: {\n                ...options === null || options === void 0 ? void 0 : options.headers,\n                Authorization: `Bearer ${authToken}`,\n            },\n        });\n    };\n}\nexports.buildBearerFetch = buildBearerFetch;\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\n    var _a;\n    return {\n        ...defaultOptions,\n        headers: {\n            ...defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers,\n            Authorization: `DPoP ${authToken}`,\n            DPoP: await oidc_client_ext_1.createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey),\n        },\n        credentials: \"include\",\n    };\n}\nfunction isExpectedAuthError(statusCode) {\n    return [401, 403].includes(statusCode);\n}\nasync function buildDpopFetch(authToken, _refreshToken, dpopKey) {\n    return async (url, options) => {\n        const response = await fetch(url, await buildDpopFetchOptions(url.toString(), authToken, dpopKey, options));\n        const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\n        const hasBeenRedirected = response.url !== url;\n        if (response.ok || failedButNotExpectedAuthError || !hasBeenRedirected) {\n            return response;\n        }\n        return fetch(response.url, await buildDpopFetchOptions(response.url, authToken, dpopKey, options));\n    };\n}\nexports.buildDpopFetch = buildDpopFetch;\n"},"sourceMaps":{"js":{"version":3,"file":"fetchFactory.js","sourceRoot":"","sources":["../../src/authenticatedFetch/fetchFactory.ts"],"names":[],"mappings":";;;AAsBA,6DAA2D;AAS3D,SAAgB,gBAAgB,CAC9B,SAAiB,EAGjB,aAAiC;IAEjC,OAAO,CAAC,IAAI,EAAE,OAAO,EAAqB,EAAE;QAC1C,OAAO,KAAK,CAAC,IAAI,EAAE;YACjB,GAAG,OAAO;YACV,WAAW,EAAE,SAAS;YACtB,OAAO,EAAE;gBACP,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,OAAO;gBACnB,aAAa,EAAE,UAAU,SAAS,EAAE;aACrC;SACF,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAhBD,4CAgBC;AAED,KAAK,UAAU,qBAAqB,CAClC,SAAiB,EACjB,SAAiB,EACjB,OAAmB,EACnB,cAA4B;;IAE5B,OAAO;QACL,GAAG,cAAc;QACjB,OAAO,EAAE;YACP,GAAG,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,OAAO;YAC1B,aAAa,EAAE,QAAQ,SAAS,EAAE;YAClC,IAAI,EAAE,MAAM,kCAAgB,CAC1B,SAAS,QACT,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,MAAM,mCAAI,KAAK,EAC/B,OAAO,CACR;SACF;QACD,WAAW,EAAE,SAAS;KACvB,CAAC;AACJ,CAAC;AAED,SAAS,mBAAmB,CAAC,UAAkB;IAI7C,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;AACzC,CAAC;AASM,KAAK,UAAU,cAAc,CAClC,SAAiB,EAGjB,aAAiC,EACjC,OAAmB;IAEnB,OAAO,KAAK,EAAE,GAAG,EAAE,OAAO,EAAqB,EAAE;QAC/C,MAAM,QAAQ,GAAG,MAAM,KAAK,CAC1B,GAAG,EACH,MAAM,qBAAqB,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CACzE,CAAC;QACF,MAAM,6BAA6B,GACjC,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACxD,MAAM,iBAAiB,GAAG,QAAQ,CAAC,GAAG,KAAK,GAAG,CAAC;QAC/C,IAAI,QAAQ,CAAC,EAAE,IAAI,6BAA6B,IAAI,CAAC,iBAAiB,EAAE;YAGtE,OAAO,QAAQ,CAAC;SACjB;QAGD,OAAO,KAAK,CACV,QAAQ,CAAC,GAAG,EACZ,MAAM,qBAAqB,CAAC,QAAQ,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CACvE,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AA3BD,wCA2BC","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { JSONWebKey } from \"jose\";\nimport { createDpopHeader } from \"@inrupt/oidc-client-ext\";\n\n/**\n * @param authToken A bearer token.\n * @param _refreshToken An optional refresh token.\n * @returns A fetch function that adds an Authorization header with the provided\n * bearer token.\n * @hidden\n */\nexport function buildBearerFetch(\n  authToken: string,\n  // TODO: We need to push this refresh token into a wrapper around the fetch,\n  //  so dependent on that wrapper existing first!\n  _refreshToken: string | undefined\n): typeof fetch {\n  return (init, options): Promise<Response> => {\n    return fetch(init, {\n      ...options,\n      credentials: \"include\",\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${authToken}`,\n      },\n    });\n  };\n}\n\nasync function buildDpopFetchOptions(\n  targetUrl: string,\n  authToken: string,\n  dpopKey: JSONWebKey,\n  defaultOptions?: RequestInit\n): Promise<RequestInit> {\n  return {\n    ...defaultOptions,\n    headers: {\n      ...defaultOptions?.headers,\n      Authorization: `DPoP ${authToken}`,\n      DPoP: await createDpopHeader(\n        targetUrl,\n        defaultOptions?.method ?? \"get\",\n        dpopKey\n      ),\n    },\n    credentials: \"include\",\n  };\n}\n\nfunction isExpectedAuthError(statusCode: number): boolean {\n  // As per https://tools.ietf.org/html/rfc7235#section-3.1 and https://tools.ietf.org/html/rfc7235#section-3.1,\n  // a response failing because the provided credentials aren't accepted by the\n  // server can get a 401 or a 403 response.\n  return [401, 403].includes(statusCode);\n}\n\n/**\n * @param authToken a DPoP token.\n * @param _refreshToken An optional refresh token.\n * @param dpopKey The private key the token is bound to.\n * @returns A fetch function that adds an Authorization header with the provided\n * DPoP token, and adds a dpop header.\n */\nexport async function buildDpopFetch(\n  authToken: string,\n  // TODO: We need to push this refresh token into a wrapper around the fetch,\n  //  so dependent on that wrapper existing first!\n  _refreshToken: string | undefined,\n  dpopKey: JSONWebKey\n): Promise<typeof fetch> {\n  return async (url, options): Promise<Response> => {\n    const response = await fetch(\n      url,\n      await buildDpopFetchOptions(url.toString(), authToken, dpopKey, options)\n    );\n    const failedButNotExpectedAuthError =\n      !response.ok && !isExpectedAuthError(response.status);\n    const hasBeenRedirected = response.url !== url;\n    if (response.ok || failedButNotExpectedAuthError || !hasBeenRedirected) {\n      // If there hasn't been a redirection, or if there has been a non-auth related\n      // issue, it should be handled at the application level\n      return response;\n    }\n    // If the request failed for auth reasons, and has been redirected, we should\n    // replay it with a new DPoP token.\n    return fetch(\n      response.url,\n      await buildDpopFetchOptions(response.url, authToken, dpopKey, options)\n    );\n  };\n}\n"]}},"error":null,"hash":"437f43bff74361a7282ee3e2be197844","cacheData":{"env":{}}}