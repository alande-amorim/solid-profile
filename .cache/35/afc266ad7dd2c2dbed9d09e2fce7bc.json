{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","dependencies":[{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js.map","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/src/Session.ts","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/package.json","includedInParent":true,"mtime":1612372540913},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1611945169054},{"name":"events","loc":{"line":4,"column":25},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/events/events.js"},{"name":"uuid","loc":{"line":5,"column":23},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/uuid/dist/esm-browser/index.js"},{"name":"./dependencies","loc":{"line":6,"column":31},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/dependencies.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Session = void 0;\nconst events_1 = require(\"events\");\nconst uuid_1 = require(\"uuid\");\nconst dependencies_1 = require(\"./dependencies\");\nclass Session extends events_1.EventEmitter {\n    constructor(sessionOptions = {}, sessionId) {\n        super();\n        this.tokenRequestInProgress = false;\n        this.login = async (options) => {\n            await this.clientAuthentication.login(this.info.sessionId, {\n                ...options,\n            });\n        };\n        this.fetch = async (url, init) => {\n            return this.clientAuthentication.fetch(url, init);\n        };\n        this.logout = async () => {\n            await this.clientAuthentication.logout(this.info.sessionId);\n            this.info.isLoggedIn = false;\n            this.emit(\"logout\");\n        };\n        this.handleIncomingRedirect = async (url = window.location.href) => {\n            if (this.info.isLoggedIn) {\n                return this.info;\n            }\n            if (this.tokenRequestInProgress) {\n                return undefined;\n            }\n            const storedSessionCookieReference = window.localStorage.getItem(\"tmp-resource-server-session-info\");\n            if (typeof storedSessionCookieReference === \"string\") {\n                function isValidSessionCookieReference(reference) {\n                    var _a;\n                    const resourceServers = Object.keys((_a = reference.sessions) !== null && _a !== void 0 ? _a : {});\n                    return (typeof reference.webId === \"string\" &&\n                        resourceServers.length > 0 &&\n                        typeof reference.sessions[resourceServers[0]].expiration === \"number\");\n                }\n                const reference = JSON.parse(storedSessionCookieReference);\n                if (isValidSessionCookieReference(reference)) {\n                    const resourceServers = Object.keys(reference.sessions);\n                    const webIdOrigin = new URL(reference.webId).hostname;\n                    const ownResourceServer = resourceServers.find((resourceServer) => {\n                        return new URL(resourceServer).hostname === webIdOrigin;\n                    });\n                    const relevantServer = ownResourceServer !== null && ownResourceServer !== void 0 ? ownResourceServer : resourceServers[0];\n                    if (reference.sessions[relevantServer].expiration - Date.now() >\n                        5 * 60 * 1000) {\n                        this.info.isLoggedIn = true;\n                        this.info.webId = reference.webId;\n                        return this.info;\n                    }\n                }\n            }\n            this.tokenRequestInProgress = true;\n            const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url);\n            if (sessionInfo) {\n                this.info.isLoggedIn = sessionInfo.isLoggedIn;\n                this.info.webId = sessionInfo.webId;\n                this.info.sessionId = sessionInfo.sessionId;\n                if (sessionInfo.isLoggedIn) {\n                    this.emit(\"login\");\n                }\n            }\n            this.tokenRequestInProgress = false;\n            return sessionInfo;\n        };\n        if (sessionOptions.clientAuthentication) {\n            this.clientAuthentication = sessionOptions.clientAuthentication;\n        }\n        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({\n                secureStorage: sessionOptions.secureStorage,\n                insecureStorage: sessionOptions.insecureStorage,\n            });\n        }\n        else {\n            this.clientAuthentication = dependencies_1.getClientAuthenticationWithDependencies({});\n        }\n        if (sessionOptions.sessionInfo) {\n            this.info = {\n                sessionId: sessionOptions.sessionInfo.sessionId,\n                isLoggedIn: false,\n                webId: sessionOptions.sessionInfo.webId,\n            };\n        }\n        else {\n            this.info = {\n                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : uuid_1.v4(),\n                isLoggedIn: false,\n            };\n        }\n    }\n    onLogin(callback) {\n        this.on(\"login\", callback);\n    }\n    onLogout(callback) {\n        this.on(\"logout\", callback);\n    }\n}\nexports.Session = Session;\n"},"sourceMaps":{"js":{"version":3,"file":"Session.js","sourceRoot":"","sources":["../src/Session.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n */\nimport { EventEmitter } from \"events\";\nimport {\n  ILoginInputOptions,\n  ISessionInfo,\n  IStorage,\n  ResourceServerSession,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport ClientAuthentication from \"./ClientAuthentication\";\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\n\nexport interface ISessionOptions {\n  /**\n   * A private storage, unreachable to other scripts on the page. Typically in-memory.\n   */\n  secureStorage: IStorage;\n  /**\n   * A storage where non-sensitive information may be stored, potentially longer-lived than the secure storage.\n   */\n  insecureStorage: IStorage;\n  /**\n   * Details about the current session\n   */\n  sessionInfo: ISessionInfo;\n  /**\n   * An instance of the library core. Typically obtained using `getClientAuthenticationWithDependencies`.\n   */\n  clientAuthentication: ClientAuthentication;\n}\n\n/**\n * A {@link Session} object represents a user's session on an application. The session holds state, as it stores information enabling acces to private resources after login for instance.\n */\nexport class Session extends EventEmitter {\n  /**\n   * Information regarding the current session.\n   */\n  public readonly info: ISessionInfo;\n\n  private clientAuthentication: ClientAuthentication;\n\n  private tokenRequestInProgress = false;\n\n  /**\n   * Session object constructor. Typically called as follows:\n   *\n   * ```typescript\n   * const session = new Session();\n   * ```\n   * @param sessionOptions The options enabling the correct instantiation of\n   * the session. Either both storages or clientAuthentication are required. For\n   * more information, see {@link ISessionOptions}.\n   * @param sessionId A magic string uniquely identifying the session.\n   *\n   */\n  constructor(\n    sessionOptions: Partial<ISessionOptions> = {},\n    sessionId?: string\n  ) {\n    super();\n\n    if (sessionOptions.clientAuthentication) {\n      this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage,\n      });\n    } else {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({});\n    }\n\n    if (sessionOptions.sessionInfo) {\n      this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId,\n      };\n    } else {\n      this.info = {\n        sessionId: sessionId ?? v4(),\n        isLoggedIn: false,\n      };\n    }\n  }\n\n  /**\n   * Triggers the login process. Note that this method will redirect the user away from your app.\n   *\n   * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.\n   * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.\n   */\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (options: ILoginInputOptions): Promise<void> => {\n    await this.clientAuthentication.login(this.info.sessionId, {\n      ...options,\n    });\n  };\n\n  /**\n   * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n   *\n   * @param url The URL from which data should be fetched.\n   * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).\n   */\n  fetch = async (url: RequestInfo, init?: RequestInit): Promise<Response> => {\n    return this.clientAuthentication.fetch(url, init);\n  };\n\n  /**\n   * Logs the user out of the application. This does not log the user out of their Solid identity provider, and should not redirect the user away.\n   */\n  logout = async (): Promise<void> => {\n    await this.clientAuthentication.logout(this.info.sessionId);\n    this.info.isLoggedIn = false;\n    this.emit(\"logout\");\n  };\n\n  /**\n   * Completes the login process by processing the information provided by the\n   * Solid identity provider through redirect.\n   *\n   * @param url The URL of the page handling the redirect, including the query\n   * parameters â€” these contain the information to process the login.\n   * Note: as a convenience, if no URL value is specified here, we default to\n   * using the browser's current location.\n   */\n  handleIncomingRedirect = async (\n    url: string = window.location.href\n  ): Promise<ISessionInfo | undefined> => {\n    if (this.info.isLoggedIn) {\n      return this.info;\n    }\n    if (this.tokenRequestInProgress) {\n      return undefined;\n    }\n\n    // Unfortunately, regular sessions are lost when the user refreshes the page or opens a new tab.\n    // While we're figuring out the API for a longer-term solution, as a temporary workaround some\n    // *resource* servers set a cookie that keeps the user logged in after authenticated requests,\n    // and expose the fact that they set it on a special endpoint.\n    // After login, we store that fact in LocalStorage. This means that we can now look for that\n    // data, and if present, indicate that the user is already logged in.\n    // Note that there are a lot of edge cases that won't work well with this approach, so it willl\n    // be removed in due time.\n    const storedSessionCookieReference = window.localStorage.getItem(\n      \"tmp-resource-server-session-info\"\n    );\n    if (typeof storedSessionCookieReference === \"string\") {\n      // TOOD: Re-use the type used when writing this data:\n      // https://github.com/inrupt/solid-client-authn-js/pull/920/files#diff-659ac87dfd3711f4cfcea3c7bf6970980f4740fd59df45f04c7977bffaa23e98R118\n      // To keep temporary code together\n      // eslint-disable-next-line no-inner-declarations\n      function isValidSessionCookieReference(\n        reference: Record<string, unknown>\n      ): reference is ResourceServerSession {\n        const resourceServers = Object.keys(\n          (reference as ResourceServerSession).sessions ?? {}\n        );\n        return (\n          typeof (reference as ResourceServerSession).webId === \"string\" &&\n          resourceServers.length > 0 &&\n          typeof (reference as ResourceServerSession).sessions[\n            resourceServers[0]\n          ].expiration === \"number\"\n        );\n      }\n      const reference = JSON.parse(storedSessionCookieReference);\n      if (isValidSessionCookieReference(reference)) {\n        const resourceServers = Object.keys(reference.sessions);\n        const webIdOrigin = new URL(reference.webId).hostname;\n        const ownResourceServer = resourceServers.find((resourceServer) => {\n          return new URL(resourceServer).hostname === webIdOrigin;\n        });\n        // Usually the user's WebID is also a Resource server for them,\n        // so we pick the expiration time for that. If it doesn't exist,\n        // we just pick the first (and probably only) one:\n        const relevantServer = ownResourceServer ?? resourceServers[0];\n        // If the cookie is valid for fewer than five minutes,\n        // pretend it's not valid anymore already, to avoid small misalignments\n        // resulting in invalid states:\n        if (\n          reference.sessions[relevantServer].expiration - Date.now() >\n          5 * 60 * 1000\n        ) {\n          this.info.isLoggedIn = true;\n          this.info.webId = reference.webId;\n          return this.info;\n        }\n      }\n    }\n    // end of temporary workaround.\n\n    this.tokenRequestInProgress = true;\n    const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(\n      url\n    );\n    if (sessionInfo) {\n      this.info.isLoggedIn = sessionInfo.isLoggedIn;\n      this.info.webId = sessionInfo.webId;\n      this.info.sessionId = sessionInfo.sessionId;\n      if (sessionInfo.isLoggedIn) {\n        // The login event can only be triggered **after** the user has been\n        // redirected from the IdP with access and ID tokens.\n        this.emit(\"login\");\n      }\n    }\n    this.tokenRequestInProgress = false;\n    return sessionInfo;\n  };\n\n  /**\n   * Register a callback function to be called when a user completes login.\n   *\n   * The callback is called when {@link handleIncomingRedirect} completes successfully.\n   *\n   * @param callback The function called when a user completes login.\n   */\n  onLogin(callback: () => unknown): void {\n    this.on(\"login\", callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when a user completes logout.\n   */\n  onLogout(callback: () => unknown): void {\n    this.on(\"logout\", callback);\n  }\n}\n"]}},"error":null,"hash":"1e99671955a1954d06ca05ea05f8684f","cacheData":{"env":{}}}