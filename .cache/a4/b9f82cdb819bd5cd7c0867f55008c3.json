{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js","dependencies":[{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js.map","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/src/SessionManager.ts","includedInParent":true,"mtime":1611945169054},{"name":"/Users/amorim.alande/Projects/pod-profile/package.json","includedInParent":true,"mtime":1612372540913},{"name":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1611945169054},{"name":"events","loc":{"line":13,"column":25},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/events/events.js"},{"name":"tsyringe","loc":{"line":14,"column":27},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/tsyringe/dist/esm5/index.js"},{"name":"./Session","loc":{"line":15,"column":26},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js"},{"name":"./dependencies","loc":{"line":16,"column":31},"parent":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js","resolved":"/Users/amorim.alande/Projects/pod-profile/node_modules/@inrupt/solid-client-authn-browser/dist/dependencies.js"}],"generated":{"js":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SessionManager = void 0;\nconst events_1 = require(\"events\");\nconst tsyringe_1 = require(\"tsyringe\");\nconst Session_1 = require(\"./Session\");\nconst dependencies_1 = require(\"./dependencies\");\nlet SessionManager = class SessionManager extends events_1.EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.sessionRecords = {};\n        this.isInitialized = false;\n        this.handledIncomingRedirect = false;\n        this.clientAuthn = dependencies_1.getClientAuthenticationWithDependencies({\n            secureStorage: options.secureStorage,\n            insecureStorage: options.insecureStorage,\n        });\n    }\n    async init() {\n        if (!this.isInitialized) {\n            await this.handleIncomingRedirect(window.location.href);\n            this.isInitialized = true;\n        }\n    }\n    addNewSessionRecord(session) {\n        const logoutCallback = () => {\n            this.emit(\"sessionLogout\", session);\n        };\n        session.onLogout(logoutCallback);\n        this.sessionRecords[session.info.sessionId] = {\n            session,\n            logoutCallback,\n        };\n        return session;\n    }\n    getSessionFromCurrentSessionInfo(sessionInfo) {\n        const sessionRecord = this.sessionRecords[sessionInfo.sessionId];\n        if (sessionRecord) {\n            sessionRecord.session.info.webId = sessionInfo.webId;\n            sessionRecord.session.info.isLoggedIn = sessionInfo.isLoggedIn;\n            return sessionRecord.session;\n        }\n        return this.addNewSessionRecord(new Session_1.Session({\n            clientAuthentication: this.clientAuthn,\n            sessionInfo,\n        }));\n    }\n    async getSessions() {\n        await this.init();\n        const sessionInfos = await this.clientAuthn.getAllSessionInfo();\n        return sessionInfos.map((sessionInfo) => this.getSessionFromCurrentSessionInfo(sessionInfo));\n    }\n    async getSession(sessionId) {\n        await this.init();\n        let session;\n        if (sessionId) {\n            const retrievedSessionInfo = await this.clientAuthn.getSessionInfo(sessionId);\n            if (retrievedSessionInfo) {\n                session = this.getSessionFromCurrentSessionInfo(retrievedSessionInfo);\n            }\n            else {\n                session = this.addNewSessionRecord(new Session_1.Session({ clientAuthentication: this.clientAuthn }, sessionId));\n            }\n        }\n        else {\n            session = this.addNewSessionRecord(new Session_1.Session({ clientAuthentication: this.clientAuthn }));\n        }\n        return session;\n    }\n    async hasSession(sessionId) {\n        await this.init();\n        return (await this.clientAuthn.getSessionInfo(sessionId)) !== undefined;\n    }\n    onSessionLogin(callback) {\n        this.on(\"sessionLogin\", callback);\n    }\n    onSessionLogout(callback) {\n        this.on(\"sessionLogout\", callback);\n    }\n    detachSession(sessionId) {\n        const sessionRecord = this.sessionRecords[sessionId];\n        if (sessionRecord) {\n            sessionRecord.session.removeListener(\"onLogout\", sessionRecord.logoutCallback);\n            delete this.sessionRecords[sessionId];\n        }\n    }\n    async handleIncomingRedirect(url) {\n        const sessionInfo = await this.clientAuthn.handleIncomingRedirect(url);\n        if (sessionInfo) {\n            const session = this.getSessionFromCurrentSessionInfo(sessionInfo);\n            this.emit(\"sessionLogin\", session);\n            session.emit(\"login\");\n            return session;\n        }\n        return undefined;\n    }\n};\nSessionManager = __decorate([\n    tsyringe_1.injectable(),\n    __metadata(\"design:paramtypes\", [Object])\n], SessionManager);\nexports.SessionManager = SessionManager;\n"},"sourceMaps":{"js":{"version":3,"file":"SessionManager.js","sourceRoot":"","sources":["../src/SessionManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport { EventEmitter } from \"events\";\nimport { ISessionInfo, IStorage } from \"@inrupt/solid-client-authn-core\";\nimport { injectable } from \"tsyringe\";\nimport { Session } from \"./Session\";\nimport ClientAuthentication from \"./ClientAuthentication\";\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\n\nexport interface ISessionManagerOptions {\n  secureStorage?: IStorage;\n  insecureStorage?: IStorage;\n}\n\nexport interface ISessionManager {\n  getSession(sessionId?: string): Promise<Session>;\n}\n\n/**\n * A SessionManager instance can be used to manage all the sessions in an\n * application, each session being associated with an individual user.\n *\n * @deprecated\n */\n@injectable()\nexport class SessionManager extends EventEmitter implements ISessionManager {\n  private clientAuthn: ClientAuthentication;\n\n  private sessionRecords: Record<\n    string,\n    { session: Session; logoutCallback: () => unknown }\n  > = {};\n\n  private isInitialized = false;\n\n  private handledIncomingRedirect = false;\n\n  /**\n   * Constructor for the SessionManager object. It is typically used as follows:\n   *\n   * ```typescript\n   * import { SessionManager } from \"@inrupt/solid-client-authn-browser\";\n   * import customStorage from \"./myCustomStorage\";\n   *\n   * const sessionManager = new SessionManager({\n   *   secureStorage: customStorage\n   * });\n   * ```\n   * See {@link IStorage} for more information on how to define your own storage mechanism.\n   *\n   * @param options Options customizing the behaviour of the SessionManager, namely to store data appropriately.\n   */\n  constructor(options: ISessionManagerOptions = {}) {\n    super();\n    this.clientAuthn = getClientAuthenticationWithDependencies({\n      secureStorage: options.secureStorage,\n      insecureStorage: options.insecureStorage,\n    });\n  }\n\n  private async init(): Promise<void> {\n    if (!this.isInitialized) {\n      await this.handleIncomingRedirect(window.location.href);\n      this.isInitialized = true;\n    }\n  }\n\n  private addNewSessionRecord(session: Session): Session {\n    const logoutCallback = (): void => {\n      this.emit(\"sessionLogout\", session);\n    };\n    session.onLogout(logoutCallback);\n    this.sessionRecords[session.info.sessionId] = {\n      session,\n      logoutCallback,\n    };\n    return session;\n  }\n\n  private getSessionFromCurrentSessionInfo(sessionInfo: ISessionInfo): Session {\n    const sessionRecord = this.sessionRecords[sessionInfo.sessionId];\n    if (sessionRecord) {\n      sessionRecord.session.info.webId = sessionInfo.webId;\n      sessionRecord.session.info.isLoggedIn = sessionInfo.isLoggedIn;\n      return sessionRecord.session;\n    }\n    return this.addNewSessionRecord(\n      new Session({\n        clientAuthentication: this.clientAuthn,\n        sessionInfo,\n      })\n    );\n  }\n\n  /**\n   * @returns all the sessions currently managed by the session manager.\n   */\n  async getSessions(): Promise<Session[]> {\n    await this.init();\n    const sessionInfos = await this.clientAuthn.getAllSessionInfo();\n    return sessionInfos.map((sessionInfo) =>\n      this.getSessionFromCurrentSessionInfo(sessionInfo)\n    );\n  }\n\n  /**\n   * Creates a new session and adds it to the session manager.\n   * If a session ID is not provided then a random UUID will be\n   * assigned as the session ID. If the session of the provided\n   * ID already exists then that session will be returned.\n   *\n   * @param sessionId An optional unique session identifier.\n   * @returns A {@link Session} associated with the given ID.\n   */\n  async getSession(sessionId?: string): Promise<Session> {\n    await this.init();\n    let session: Session;\n    if (sessionId) {\n      const retrievedSessionInfo = await this.clientAuthn.getSessionInfo(\n        sessionId\n      );\n      if (retrievedSessionInfo) {\n        session = this.getSessionFromCurrentSessionInfo(retrievedSessionInfo);\n      } else {\n        session = this.addNewSessionRecord(\n          new Session({ clientAuthentication: this.clientAuthn }, sessionId)\n        );\n      }\n    } else {\n      session = this.addNewSessionRecord(\n        new Session({ clientAuthentication: this.clientAuthn })\n      );\n    }\n    return session;\n  }\n\n  /**\n   * @param sessionId A unique session identifier.\n   * @returns A Promise resolving to true if a session associated with the given ID exists, and false if not.\n   */\n  async hasSession(sessionId: string): Promise<boolean> {\n    await this.init();\n    return (await this.clientAuthn.getSessionInfo(sessionId)) !== undefined;\n  }\n\n  /**\n   * Registers a callback to be called when a session is logged in.\n   *\n   * @param callback a function executed when a session logs in, with the session as a parameter.\n   */\n  onSessionLogin(callback: (session: Session) => unknown): void {\n    this.on(\"sessionLogin\", callback);\n  }\n\n  /**\n   * Registers a callback to be called when a session is logged out.\n   *\n   * @param callback a function executed when a session logs out, with the session as a parameter.\n   */\n  onSessionLogout(callback: (session: Session) => unknown): void {\n    this.on(\"sessionLogout\", callback);\n  }\n\n  /**\n   * Removes a session from the pool managed by the manager. This is typically useful\n   * when a user logs out of the application, so that the number of managed session\n   * is not ever-growing. Note that this specific function **does not log out the session**,\n   * it only removes references to it, so after this call the session will become unreachable.\n   *\n   * @param sessionId A unique session identifier.\n   * @since 0.2.0\n   */\n  detachSession(sessionId: string): void {\n    const sessionRecord = this.sessionRecords[sessionId];\n    if (sessionRecord) {\n      sessionRecord.session.removeListener(\n        \"onLogout\",\n        sessionRecord.logoutCallback\n      );\n      delete this.sessionRecords[sessionId];\n    }\n  }\n\n  /**\n   * Processes the information sent by the identity provider after\n   * the user has logged in, in order to return a logged in {@link Session}.\n   *\n   * @param url The URL to which the user is being redirected.\n   * @returns The {@link Session} that completed login if the process has been successful.\n   */\n  async handleIncomingRedirect(url: string): Promise<Session | undefined> {\n    const sessionInfo = await this.clientAuthn.handleIncomingRedirect(url);\n    if (sessionInfo) {\n      const session = this.getSessionFromCurrentSessionInfo(sessionInfo);\n      this.emit(\"sessionLogin\", session);\n      session.emit(\"login\");\n      return session;\n    }\n    return undefined;\n  }\n}\n"]}},"error":null,"hash":"6d52689355cd3ecf7a28d9310ff0d347","cacheData":{"env":{}}}